# Chapter 1 - Crunching Knowledge

What happens when your software isn't domain-driven?

__waterfall method__

business experts talk to analysts - who abstract and pass the result to the programmers - who then create the software. This approach lacks feedback. anaylsts are the ones with the power to create the model


__iterative process__

sometimes projects take on an iterative process but fail to build up knowledge. devs get the experts to describe a feature, then they go build it. they show the experts the result and then ask what to do next.

if devs aren't interested in the domain, they only learn what the __application should do__, not the principles behind it. useful software can be built this way but this software will never get to a point where it can roll out powerful features


## Continuous Learning

Domains that seem less technically daunting can be deceiving: we don't realize how much we don't know. This ignorance leads us to make false assumptions.

__All projects leak knowledge__

* It's super important to learn about the domain that you're working in
* Take the example of the author that needed to build software for a PCB
* Early work is __essential__: Knowledge is gained by team members, devs, and domain experts and a __shared language__ is established

## Knowledge Rich Design

* Domain experts are usually not aware of how complex their mental processes are. They fill in knowledge with what they consider to be common sense. __Software can't do this__
* It is with knowledge crunching in close collaboration with software experts that the rules are clarified, fleshed out, and reconciled
* With this kind of collaboration, you can design better software. The example that was given talks about implementing a *Strategy* pattern in the context of overbooking cargo shipments
