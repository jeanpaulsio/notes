# Chapter 2 - Communication and the use of language

> A domain model can be the core of a common language for a software project. The model is a set of concepts built up in the heads of people on the project, with terms and relationships that reflect domain insight

* There is a linguistic divide. Domain experts use their own jargon. Developers use their own jargon
* Words and meanings can get abstracted through communication.
* It's kind of like playing telephone - the original meaning might get lost in translation

> A project needs a common language that is more robust than the lowest common denominator

* An example of this - pointing to Whiz Tutor - the idea of coupons vs. referals
* A sort of back and forth is required to find common language. Then, as a developer, you can go back and update class diagrams and rename classes and methods in the code - or even change the behavior

> Commit the team to exercising that (ubiquitous) language relentlessly in all communication within the team and in the code. Use the same language in diagrams, writing, and especially speech. 

## Example - Page 27 - Cargo Router

* This example shows what happens when the dev responds back to the domain expert using a ton of jargon. 

## Modeling out loud

* It isn't easy to establish a common language. It requires hard work. Think about taking a foreign language class where you're not allowed to speak English

There's one of those charts - venn diagram thingies

- technical aspects / tech terms || UBIQUITOUS LANGUAGE || business terms devs don't understand

## Documents and Diagrams

* Diagrams shouldn't be the end all
* They are a means of communication and explanation - they facilitate brainstorming
* They represent skeletons of an idea

## Explanatory Models

> The thrust of this book is that one model should underlie implementation, design, and team communication. 

Model as in, not the object model


