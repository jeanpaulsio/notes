# Preface

> This book provides a framework for making design decisions and a technical vocabulary for discussing domain design. It is a synthesis of widley accepted best practices along with my own insights and experiences

* How to meet the ongoing needs of an organization
* When you don't use domain driven design, it can be hard to iterate and create a "second version" in the future

The premise of this book:

1. For most software projects, the primary focus should be on the domain and domain logic.
2. Complex domain designs should be based on a model.

* Domain driven design is both a way of thinking and a set of priorities, aimed at accelerating software projects that have to deal with complicated domains.

This book has __two__ prereqs:

1. Development is iterative
2. Developers and domain experts have a close relationship

This book has __four__ parts

1. Defines terms and gives an overview of the implications of using the domain model to drive communication and design.
2. Bridges gap between models and practical, running software
3. Assembling building blocks into practical models
4. Dealing with situations that arise in complex systems

* Every software program relates to some activity or interest of its user. The subject area to which the user applies the program is the **domain** of the software.
* To developer software that is valuably involved in user's activities, a dev team must bring to bear a body of knowledge related to those activities.


## The Heart of Software

* The heart of software is its ability to solve domain-related problems for its user.
* When the domain is complex, this is a difficult task
* __Yet these are not the priorities on most software projects__. Most talented devs do not have much interest in learrning about the specific domain in which they are working, must less making a major commitment to expand their domain-modeling skills.
* Technical people like working on technical things.

> Domain work is messy and demands a lot of complciated new kknowledge that doesn't seem to add to a computer scientist's capabilities.

What ends up happening is that you have a technical person trying to solve domain problems with technology!!!
